МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


ФАКУЛЬТЕТ КОМП’ЮТЕРНИХ НАУК

КАТЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ





ЗВІТ

до практичного завдання №2 з дисципліни

«Аналіз та рефакторинґ коду»

на тему: «Методи рефакторинґу коду програмного забезпечення: Add Parameter​, Move Method​, Consolidate Conditional Expression​»







Виконав:                                                                                                  Перевірив:

ст. гр. ПЗПІ-23-6                       				ст. викладач катедри ПІ

Бєлік Єгор Васильович		                                        Сокорчук Ігор Петрович








Харків 2025

1 ІСТОРІЯ ЗМІН 


№
Дата
Версія звіту
Опис змін та виправлень
1
30.11.2025
1
Створено звіт




2 ЗАВДАННЯ


     Метою цієї практичної роботи є ґрунтовне опанування методів рефакторинґу програмного забезпечення та набуття практичних навичок їх застосування для поліпшення внутрішньої структури програми без зміни її зовнішньої функціональності. У ході виконання завдання потрібно вивчити базові принципи рефакторинґу, викладені Мартіном Фаулером, обрати три індивідуальні техніки та продемонструвати їх використання на фрагментах власного коду, створеного в межах попередніх лабораторних робіт чи курсових проєктів.

     Студент має знайти у своєму коді ділянки, що містять «запахи коду» або інші структурні недосконалості, виправити їх за допомогою обраних методів і представити приклади «до» та «після» внесених змін. Для кожного прикладу потрібно обґрунтувати необхідність рефакторинґу, пояснити проблему, яку вирішує відповідна техніка, та описати переваги отриманого результату з погляду читабельності, гнучкості та зручності супроводу.

     За підсумками виконаної роботи студент повинен підготувати презентацію, що міститиме теоретичний вступ, детальний аналіз трьох вибраних прикладів рефакторинґу, огляд інструментів автоматизованого вдосконалення коду у сучасних середовищах розробки та підсумкові висновки щодо важливості регулярного покращення якості програмного коду.

      


3 ОПИС ВИКОНАНОЇ РОБОТИ

     3.1 Вибір мови програмування та джерел

     Для виконання практичної роботи обрано три ефективні методи рефакторингу, які допомагають покращити структуру та читабельність коду. Метою застосування цих технік є підвищення якості програмного забезпечення, зробивши його більш зрозумілим, підтримуваним та розширюваним. Всі методи є універсальними та можуть застосовуватися в будь-якій мові програмування.

     До переліку увійшли:

- Add Parameter – додає параметр до методу замість використання полів класу, що спрощує API та усуває залежність від стану.

- Move Method – переміщує метод до класу, з даними якого він найбільше взаємодіє, щоб зменшити зв'язаність компонентів.

- Consolidate Conditional Expression – об'єднує кілька умов з однаковим результатом в один вираз, усуваючи дублювання коду.


3.2 Метод Add Parameter (додавання параметру)

     Ця техніка рефакторингу спрямована на усунення прихованих залежностей методу від стану об'єкта. Вона застосовується, коли результат роботи функції залежить від даних, які зберігаються у полях класу, але ці дані змінюються від виклику до виклику. Замість того, щоб змушувати об'єкт пам'ятати поточний контекст, доцільніше передати цей контекст явно через аргументи.

     У початковій реалізації класу Logger архітектура страждала від проблеми розділеного в часі налаштування. Метод log не знав самостійно, який рівень важливості надати повідомленню — він покладався на глобальний перемикач isDebugMode. Це змушувало клієнтський код виконувати зайві маніпуляції: спершу встановлювати прапорець у потрібне положення методом setDebugMode, а лише потім викликати логування. Такий підхід є небезпечним, оскільки існує ризик забути скинути налаштування, що призведе до некоректної роботи наступних викликів.


1  // server/src/utils/Logger.ts

2  class Logger {

3    private isDebugMode: boolean = false;

4

5    public log(message: string): void {

6      if (this.isDebugMode) {

7        console.log(`[DEBUG] ${new Date().toLocaleTimeString()}: ${message}`);

8      } else {

9        console.log(`[INFO] ${new Date().toLocaleTimeString()}: ${message}`);

10     }

11   }

12

13   public setDebugMode(status: boolean): void {

14     this.isDebugMode = status;

15   }

16 }

17

18 const logger = new Logger();

19 // Незручність використання: необхідність зміни стану перед дією

20 logger.setDebugMode(false);

21 logger.log("Sensor data successfully stored.");

22 logger.setDebugMode(true);

23 logger.log("Attempting MQTT connection.");


     Під час рефакторингу було змінено сигнатуру методу log. Тепер рівень логування (DEBUG або INFO) передається безпосередньо в момент виклику як другий параметр. Це дозволило повністю видалити внутрішнє поле стану та метод-сетер, перетворивши логер на "stateless" (безстановий) сервіс. Тепер кожен виклик методу є самодостатнім та атомарним, що значно спрощує читання коду та його тестування, адже поведінка методу залежить виключно від переданих аргументів.

     

1  // server/src/utils/Logger.ts

2  type Level = 'DEBUG' | 'INFO';

3

4  class Logger {

5    public log(message: string, level: Level): void {

6      console.log(`[${level}] ${new Date().toLocaleTimeString()}: ${message}`);

7    }

8  }

9

10 const logger = new Logger();

11

12 // Виклик став прямим та однозначним

13 logger.log("Sensor data successfully stored.", 'INFO');

14 logger.log("Attempting MQTT connection.", 'DEBUG');

     

     3.3 Метод Move Method (переміщення методу)

     Цей метод рефакторингу застосовується для оптимізації архітектури програми у випадках, коли метод класу більше взаємодіє з даними іншого класу, ніж зі своїми власними, або коли логіка методу концептуально належить до іншої предметної області. Зайва зв'язність (coupling) між класами ускладнює підтримку коду, тому переміщення функціоналу до "власника" даних дозволяє покращити розподіл відповідальностей та зробити систему більш модульною.

     

     У початковій структурі проєкту було виявлено порушення принципу єдиної відповідальності у класі Sensor. Цей клас містив метод isHighRisk, який визначав, чи є показники сенсора критичними. Хоча технічно метод використовував поле value цього ж класу, семантично логіка оцінки ризиків та прийняття рішення про активацію тривоги належить сервісному шару, а не сутності, що зберігає дані. Це перетворювало Sensor з простого носія даних на об'єкт із бізнес-логікою, яка йому не властива.

     

     

1  // Sensor.ts

2  class Sensor {

3    private value: number = 850;

4

5    public getValue(): number {

6      return this.value;

7    }

8

9    // Логіка, що знаходиться не на своєму місці

10   public isHighRisk(): boolean {

11     return this.value > 900;

12   }

13 }

14

15 class AlarmService {

16   public check(sensor: Sensor): void {

17     // Сервіс запитує логіку у об'єкта даних

18     if (sensor.isHighRisk()) {

19       console.log("ALARM: High risk detected.");

20     } else {

21       console.log("INFO: Sensor value is safe.");

22     }

23   }

24 }

25

26 const service = new AlarmService();

27 service.check(new Sensor());



     У ході рефакторингу метод визначення ризику було перенесено до класу AlarmService, де він і має знаходитися згідно з логікою роботи системи. Тепер Sensor залишається простим джерелом даних (чиста інкапсуляція стану), а AlarmService бере на себе відповідальність за аналіз цих даних та прийняття рішень. Це зменшило залежність класу сенсора від правил бізнес-логіки та дозволило змінювати критерії тривоги (наприклад, поріг у 900 одиниць) без необхідності втручання в код самого сенсора.

     

1  // Sensor.ts

2  class Sensor {

3    private value: number = 850;

4

5    public getValue(): number {

6      return this.value;

7    }

8  }

9

10 // AlarmService.ts

11 class AlarmService {

12   // Логіку переміщено до сервісу, який нею керує

13   public isHighRisk(sensor: Sensor): boolean {

14     return sensor.getValue() > 900;

15   }

16

17   public check(sensor: Sensor): void {

18     if (this.isHighRisk(sensor)) {

19       console.log("ALARM: High risk detected.");

20     } else {

21       console.log("INFO: Sensor value is safe.");

22     }

23   }

24 }

25

26 const service = new AlarmService();

27 service.check(new Sensor());


     3.4 Метод Consolidate Conditional Expression (об'єднання умовного виразу)

     Цей метод рефакторингу призначений для усунення дублювання коду в умовних конструкціях. Часто в коді зустрічаються ситуації, коли низка незалежних перевірок (операторів if) призводить до виконання однієї й тієї самої дії. Хоча синтаксично це є коректним, така структура розмиває логіку програми: читачу коду доводиться аналізувати кожну гілку окремо, щоб зрозуміти, що всі вони ведуть до однакового результату. Об'єднання таких перевірок в один вираз робить код більш компактним та чітко демонструє, що це єдина логічна умова.

     У класі AlertDispatcher було виявлено фрагмент коду, що порушував принцип DRY (Don't Repeat Yourself). Метод dispatch містив дві послідовні перевірки: на перевищення порогового значення (isThresholdExceeded) та на втрату з'єднання (isConnectionLost). В обох випадках реакція системи була ідентичною — виклик методу sendCriticalAlert(). Така реалізація ускладнювала підтримку: якби виникла потреба змінити реакцію на критичну подію (наприклад, додати запис у лог перед відправкою), розробнику довелося б дублювати зміни у двох місцях, що підвищує ризик помилки.


1  // server/src/alert/AlertDispatcher.ts

2  class AlertDispatcher {

3    public dispatch(isThresholdExceeded: boolean, isConnectionLost: boolean): void {

4      // Перша умова

5      if (isThresholdExceeded) {

6        this.sendCriticalAlert();

7      }

8

9      // Друга умова з аналогічною дією

10     if (isConnectionLost) {

11       this.sendCriticalAlert();

12     }

13   }

14

15   private sendCriticalAlert(): void {

16     console.log("CRITICAL: Sending immediate evacuation notice.");

17   }

18 }

     

     Під час рефакторингу окремі умовні оператори було замінено на один, використовуючи логічний оператор "АБО" (||). Тепер код чітко відображає бізнес-правило: "якщо сталося будь-що з переліченого (перевищення порогу або втрата зв'язку), необхідно надіслати критичне сповіщення". Це не лише скоротило кількість рядків коду, але й зробило метод більш семантично цілісним, усунувши дублювання виклику функції сповіщення.

     

1  // server/src/alert/AlertDispatcher.ts

2  class AlertDispatcher {

3    public dispatch(isThresholdExceeded: boolean, isConnectionLost: boolean): void {

4      // Об'єднана умова: чіткий намір та відсутність дублювання

5      if (isThresholdExceeded || isConnectionLost) {

6        this.sendCriticalAlert();

7      }

8    }

9

10   private sendCriticalAlert(): void {

11     console.log("CRITICAL: Sending immediate evacuation notice.");

12   }

13 }

14

15 const dispatcher = new AlertDispatcher();

16 dispatcher.dispatch(false, true);




ВИСНОВКИ


     У ході виконання практичної роботи було досліджено та успішно застосовано ефективні методи рефакторингу коду на прикладі мови TypeScript. Використання таких технік, як Add Parameter, Move Method та Consolidate Conditional Expression, дозволило оптимізувати структуру програмного забезпечення, зробивши її більш логічною та гнучкою.

     Зокрема, вдалося ефективно усунути поширені «запахи коду»: приховані залежності методу від змінного стану об'єкта, порушення принципу розподілу відповідальностей (коли логіка знаходиться не в тому класі, де дані) та дублювання коду в умовних розгалуженнях. Практичні приклади продемонстрували, що явна передача контексту через параметри, правильна локалізація бізнес-логіки та об'єднання перевірок значно підвищують читабельність коду та спрощують його подальшу підтримку.

     

      


ВИКОРИСТАНІ ДЖЕРЕЛА


1. Фаулер, М. (2019). Рефакторинг. Поліпшення існуючого коду. Pearson Education. URL: https://martinfowler.com/books/refactoring.html (дата звернення: 30.11.2025).

2. Martin, R. C. (2008). Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall. URL: https://www.oreilly.com/library/view/clean-code-a/9780132350884/ (дата звернення: 30.11.2025).

3. Документація IDE (JetBrains, Visual Studio Code) з функціями рефакторингу. URL: https://www.jetbrains.com/help/idea/refactoring-source-code.html (дата звернення: 30.11.2025).

4. Онлайн-ресурси та статті з програмування, присвячені рефакторингу. URL: https://refactoring.guru/uk/refactoring (дата звернення: 30.11.2025).


 


ДОДАТОК А
Відеозапис

Відеозапис доповіді: https://youtu.be/Wmc-8ynI-9s

Хронологічний опис відеозапису:

0:00 Титульний слайд презентації
0:10 Вступ
1:10 Методи рефакторинґу
1:39 Опис методу Add Parameter
2:17 Приклад рефакторинґу методом Add Parameter
2:55 Опис методу Move Method
3:28 Приклад рефакторинґу методом Move Method
4:12 Опис методу Consolidate Conditional Expression
4:46 Приклад рефакторинґу методом Consolidate Conditional Expression
5:32 Інструменти для автоматизації рефакторинґу
6:03 Висновки
6:27 Список використаних джерел



ДОДАТОК Б

Слайди презентації


Рисунок Б.1 – Титульний слайд презентації



Рисунок Б.2 – Вступ



Рисунок Б.3 – Методи рефакторинґу



Рисунок Б.4 – Опис методу Add Parameter




Рисунок Б.5 – Приклад рефакторинґу методом Add Parameter



Рисунок Б.6 – Опис методу Move Method



Рисунок Б.7 – Приклад рефакторинґу методом Move Method



Рисунок Б.8 – Опис методу Consolidate Conditional Expression


Рисунок Б.9 – Приклад рефакторинґу методом Consolidate Conditional Expression



Рисунок Б.10 – Інструменти для автоматизації рефакторинґу


Рисунок Б.11 – Висновки



Рисунок Б.12 – Список використаних джерел


1



